import tkinter as tk
from tkinter import ttk, messagebox, filedialog
import requests
import json
import threading
from datetime import datetime
from dateutil.parser import isoparse, ParserError
import time
import queue
import os

# Global variables for thread safety
update_queue = queue.Queue()
is_fetching = False
last_update_time = None

def fetch_cves():
    global is_fetching, last_update_time
    try:
        is_fetching = True
        status_label.config(text="Fetching CVEs...", fg="yellow")
        root.update_idletasks()

        headers = {
            'apiKey': 'PUT KEY HERE'
        }
        
        current_year = datetime.now().year
        start_date = f"{current_year}-03-22T00:00:00.000+01:00"
        end_date = datetime.now().strftime("%Y-%m-%dT%H:%M:%S.000+01:00")
        
        results_per_page = 20
        start_index = 0
        all_cves = []
        
        while True:
            url = "https://services.nvd.nist.gov/rest/json/cves/2.0/"
            params = {
                'lastModStartDate': start_date,
                'lastModEndDate': end_date,
                'resultsPerPage': results_per_page,
                'startIndex': start_index
            }
            
            try:
                response = requests.get(url, headers=headers, params=params, timeout=30)
                print(f"Requesting URL: {response.url}")
                
                response.raise_for_status()
                data = response.json()
                vulnerabilities = data.get("vulnerabilities", [])
                print(f"found {len(vulnerabilities)} vulns here")
                if not vulnerabilities:
                    print("nothing")
                    break
                    
                all_cves.extend(vulnerabilities)
                
                # Update status with progress
                status_label.config(text=f"Fetching CVEs... ({len(all_cves)} found so far)", fg="yellow")
                root.update_idletasks()
                
                total_results = data.get("totalResults", 0)
                if start_index + results_per_page >= total_results:
                    break
                    
                start_index += results_per_page
                time.sleep(6)  # Rate limiting
                
            except requests.exceptions.RequestException as e:
                print(f"Request failed: {e}")
                if hasattr(e, 'response') and e.response is not None:
                    print(f"Response status code: {e.response.status_code}")
                    print(f"Response text: {e.response.text}")
                break
            
        last_update_time = datetime.now()
        return all_cves
        
    except Exception as e:
        status_label.config(text=f"An error occurred: {e}", fg="red")
        print(f"An error occurred: {e}")
        return []
    finally:
        is_fetching = False

def update_feed():
    if is_fetching:
        messagebox.showwarning("Warning", "A fetch operation is already in progress. Please wait.")
        return
        
    def update_thread():
        try:
            cves = fetch_cves()
            # Update GUI in the main thread
            root.after(0, lambda: update_feed_display(cves))
        except Exception as e:
            root.after(0, lambda: status_label.config(text=f"Error: {e}", fg="red"))
    
    threading.Thread(target=update_thread, daemon=True).start()

def update_feed_display(cves):
    try:
        print(f"Updating feed with {len(cves)} CVEs")
        feed_text.config(state=tk.NORMAL)
        feed_text.delete(1.0, tk.END)
        
        if not cves:
            feed_text.insert(tk.END, "No CVEs found for the specified date range.\n")
        else:
            for cve in cves:
                cve_data = cve.get("cve", {})
                id = cve_data.get("id", "Unknown")
                published = cve_data.get("published", "Unknown")
                description = cve_data.get("descriptions", [{}])[0].get("value", "No description available.")

                # Get severity information
                metrics = cve_data.get("metrics", {})
                cvss_v3 = metrics.get("cvssV3_1", {})
                severity = cvss_v3.get("baseSeverity", "Unknown")
                score = cvss_v3.get("baseScore", "Unknown")

                # Insert CVE ID in yellow
                feed_text.insert(tk.END, "CVE ID: ", 'yellow')
                feed_text.insert(tk.END, f"{id}\n")
                
                # Insert published date
                feed_text.insert(tk.END, f"Published: {published}\n")
                
                # Insert severity with color coding
                severity_tag = f"severity_{severity.lower()}" if severity.lower() in ['high', 'medium', 'low'] else None
                feed_text.insert(tk.END, "Severity: ", severity_tag)
                feed_text.insert(tk.END, f"{severity} (Score: {score})\n", severity_tag)
                
                # Insert description
                feed_text.insert(tk.END, f"Description: {description}\n")
                
                # Insert affected systems in blue
                feed_text.insert(tk.END, "Affected Systems:\n", 'blue')
                affected = []
                for config in cve_data.get("configurations", []):
                    nodes = config.get("nodes", [])
                    for node in nodes:
                        for cpe_match in node.get("cpeMatch", []):
                            affected.append(cpe_match.get("criteria", "Unknown"))
                
                affected_text = "\n".join(affected) if affected else "No affected systems listed."
                feed_text.insert(tk.END, affected_text + "\n", 'blue')
                
                # Insert separator
                feed_text.insert(tk.END, "-"*80 + "\n")
                
                feed_text.see(tk.END)
        
        feed_text.config(state=tk.DISABLED)
        status_label.config(text=f"Found {len(cves)} CVEs. Last updated: {last_update_time.strftime('%Y-%m-%d %H:%M:%S')}", fg="green")
        
    except Exception as e:
        status_label.config(text=f"Error updating display: {e}", fg="red")
        print(f"Error updating display: {e}")

def export_to_json():
    if is_fetching:
        messagebox.showwarning("Warning", "A fetch operation is already in progress. Please wait.")
        return
        
    def export_thread():
        cves = fetch_cves()
        root.after(0, lambda: save_json(cves))
    
    threading.Thread(target=export_thread, daemon=True).start()

def save_json(cves):
    file_path = filedialog.asksaveasfilename(
        defaultextension=".json",
        filetypes=[("JSON files", "*.json"), ("All files", "*.*")]
    )
    if file_path:
        with open(file_path, 'w') as f:
            json.dump(cves, f, indent=4)
        messagebox.showinfo("Export Successful", "Data exported to JSON successfully!")

def refresh_feed_daily():
    update_feed()
    # Schedule next update in 24 hours
    root.after(86400000, refresh_feed_daily)  # 24 hours in milliseconds

def create_gui():
    global root, status_label, feed_text
    
    # GUI Setup with Dark Mode
    root = tk.Tk()
    root.title("CVE Threat Feed")
    root.geometry("1200x800")
    root.configure(bg="#1e1e1e")

    # Taskbar with Buttons
    taskbar = tk.Frame(root, bg="#333333")
    taskbar.pack(side=tk.TOP, fill=tk.X)

    refresh_button = tk.Button(taskbar, text="Refresh Feed", command=update_feed, bg="#555555", fg="white")
    refresh_button.pack(side=tk.LEFT, padx=10, pady=10)

    export_button = tk.Button(taskbar, text="Export to JSON", command=export_to_json, bg="#555555", fg="white")
    export_button.pack(side=tk.LEFT, padx=10)

    exit_button = tk.Button(taskbar, text="Exit", command=root.quit, bg="#555555", fg="white")
    exit_button.pack(side=tk.RIGHT, padx=10)

    # Status Label
    status_label = tk.Label(root, text="Ready", bg="#1e1e1e", fg="white", font=("Arial", 12))
    status_label.pack(side=tk.BOTTOM, fill=tk.X)

    # Feed Display
    feed_frame = tk.Frame(root, bg="#1e1e1e")
    feed_frame.pack(fill=tk.BOTH, expand=True)

    feed_text = tk.Text(feed_frame, wrap=tk.WORD, state=tk.DISABLED, bg="#1e1e1e", fg="white", font=("Consolas", 10))
    feed_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

    scrollbar = ttk.Scrollbar(feed_frame, orient="vertical", command=feed_text.yview)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
    feed_text.config(yscrollcommand=scrollbar.set)
    
    # Configure text tags
    feed_text.tag_configure('yellow', foreground='yellow')
    feed_text.tag_configure('blue', foreground='#00ffff')  # Bright blue for affected systems
    feed_text.tag_configure('severity_high', foreground='red')
    feed_text.tag_configure('severity_medium', foreground='orange')
    feed_text.tag_configure('severity_low', foreground='green')

    # Start the feed updates once per day
    refresh_feed_daily()

    return root

if __name__ == "__main__":
    root = create_gui()
    root.mainloop()
