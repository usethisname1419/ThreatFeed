import tkinter as tk
from tkinter import ttk, messagebox, filedialog
import requests
import json
import threading
from datetime import datetime, timedelta
from dateutil.parser import isoparse, ParserError
import time
import queue
import os
import re

# Global variables for thread safety
update_queue = queue.Queue()
is_fetching = False
last_update_time = None
current_shodan_result_index = 0
shodan_results = []
nist_api_key = ""
shodan_api_key = ""
is_started = False
manual_search_button = None
CACHE_FILE = "cve_cache.json"
CACHE_EXPIRY_HOURS = 48 


def get_resource_path(relative_path):
    """ Get the path of a resource, either bundled or as a normal file """
    if getattr(sys, 'frozen', False):
        # Running as a bundled executable
        return os.path.join(os.path.dirname(sys.executable), relative_path)
    else:
        # Running as a normal script
        return os.path.join(os.path.dirname(__file__), relative_path)

def extract_severity(description):
    # Look for severity in description
    severity_patterns = [
        r"classified as (critical|high|medium|low)",
        r"rated as (critical|high|medium|low)",
        r"has been classified as (critical|high|medium|low)",
        r"classified as (critical|high|medium|low) severity"
    ]
    
    for pattern in severity_patterns:
        match = re.search(pattern, description.lower())
        if match:
            return match.group(1).capitalize()
    return "Unknown"

def extract_search_query(description):
    # Extract product name and version
    product_pattern = r"found in ([^,]+?)(?:\s+\d+\.\d+)?"
    match = re.search(product_pattern, description)
    if match:
        return match.group(1).strip()
    return None

def save_api_keys():
    global nist_api_key, shodan_api_key
    nist_api_key = nist_key_entry.get().strip()
    shodan_api_key = shodan_key_entry.get().strip()
    
    if not nist_api_key:
        messagebox.showwarning("Warning", "Please enter your NIST API key")
        return
    
    # Use the correct path for saving the JSON file
    api_keys_path = get_resource_path("api_keys.json")
    
    # Save the keys to the file
    try:
        with open(api_keys_path, "w") as f:
            json.dump({
                "nist_api_key": nist_api_key,
                "shodan_api_key": shodan_api_key
            }, f)
        messagebox.showinfo("Success", "API keys saved successfully")
    except Exception as e:
        messagebox.showerror("Error", f"Failed to save API keys: {e}")
        return
    
    api_window.destroy()
    
    # Enable the Start button after keys are saved
    start_button.config(state=tk.NORMAL)
    update_shodan_ui_state()
    update_status_label()

def load_api_keys():
    global nist_api_key, shodan_api_key
    try:
        # Use the correct path for loading the JSON file
        api_keys_path = get_resource_path("api_keys.json")
        
        with open(api_keys_path, "r") as f:
            keys = json.load(f)
            nist_api_key = keys.get("nist_api_key", "")
            shodan_api_key = keys.get("shodan_api_key", "")
            nist_key_entry.insert(0, nist_api_key)
            shodan_key_entry.insert(0, shodan_api_key)
            
            if nist_api_key:
                start_button.config(state=tk.NORMAL)
                update_status_label()
    except FileNotFoundError:
        update_status_label()
    except Exception as e:
        messagebox.showerror("Error", f"Failed to load API keys: {e}")


def start_feed():
    global is_started
    if not nist_api_key:
        messagebox.showwarning("Warning", "Please set your NIST API key first")
        return
    
    is_started = True
    start_button.config(state=tk.DISABLED)
    status_label.config(text="Starting feed...", fg="yellow")
    update_feed()
    refresh_feed_daily()

def show_api_keys_window():
    global api_window, nist_key_entry, shodan_key_entry
    
    api_window = tk.Toplevel(root)
    api_window.title("API Keys")
    api_window.geometry("400x200")
    api_window.configure(bg="#1e1e1e")
    
    # NIST API Key
    nist_frame = tk.Frame(api_window, bg="#1e1e1e")
    nist_frame.pack(fill=tk.X, padx=10, pady=10)
    
    nist_label = tk.Label(nist_frame, text="NIST API Key (Required):", bg="#1e1e1e", fg="white")
    nist_label.pack(side=tk.LEFT)
    
    nist_key_entry = tk.Entry(nist_frame, width=40, bg="#333333", fg="white")
    nist_key_entry.pack(side=tk.LEFT, padx=5)
    
    # Shodan API Key
    shodan_frame = tk.Frame(api_window, bg="#1e1e1e")
    shodan_frame.pack(fill=tk.X, padx=10, pady=10)
    
    shodan_label = tk.Label(shodan_frame, text="Shodan API Key (Optional):", bg="#1e1e1e", fg="white")
    shodan_label.pack(side=tk.LEFT)
    
    shodan_key_entry = tk.Entry(shodan_frame, width=40, bg="#333333", fg="white")
    shodan_key_entry.pack(side=tk.LEFT, padx=5)
    
    # Save Button
    save_button = tk.Button(api_window, text="Save API Keys", command=save_api_keys, bg="#555555", fg="white")
    save_button.pack(pady=20)
    
    load_api_keys()


def update_shodan_ui_state():
    # Enable/disable Shodan-related UI elements based on API key presence
    has_shodan_key = bool(shodan_api_key)
    
    # Update manual search if elements exist
    if manual_search_entry:
        manual_search_entry.config(state=tk.NORMAL if has_shodan_key else tk.DISABLED)
    if manual_search_button:
        manual_search_button.config(state=tk.NORMAL if has_shodan_key else tk.DISABLED)
    
    # Update Shodan results panel
    if shodan_results_text:
        shodan_results_text.config(state=tk.NORMAL if has_shodan_key else tk.DISABLED)
        if not has_shodan_key:
            shodan_results_text.delete(1.0, tk.END)
            shodan_results_text.insert(tk.END, "Shodan API key not configured. Enter your Shodan API key to enable Shodan searches.")
    if next_result_button:
        next_result_button.config(state=tk.DISABLED)

def display_shodan_results():
    global current_shodan_result_index, shodan_results
    
    if not shodan_results:
        messagebox.showwarning("No Results", "No Shodan results available.")
        return
        
    if current_shodan_result_index >= len(shodan_results):
        current_shodan_result_index = 0
        
    result = shodan_results[current_shodan_result_index]
    shodan_results_text.config(state=tk.NORMAL)
    shodan_results_text.delete(1.0, tk.END)
    shodan_results_text.insert(tk.END, json.dumps(result, indent=2))
    shodan_results_text.config(state=tk.DISABLED)
    
    current_shodan_result_index += 1
    next_result_button.config(state=tk.NORMAL)

def search_shodan(cve_id=None, description=None):
    global shodan_results, current_shodan_result_index
    
    if not shodan_api_key:
        messagebox.showwarning("Warning", "Please set your Shodan API key first")
        return
    
    # If no CVE ID provided, use the manual search entry
    if cve_id is None:
        cve_id = manual_search_entry.get().strip()
        if not cve_id:
            messagebox.showwarning("Warning", "Please enter a CVE ID to search")
            return
    
    # Extract search query from description
    search_query = extract_search_query(description) if description else None
    if not search_query:
        messagebox.showwarning("Warning", "Could not extract search query from CVE description")
        return
    
    def search_thread():
        try:
            url = f"https://api.shodan.io/shodan/host/search?key={shodan_api_key}&query={search_query}"
            response = requests.get(url)
            response.raise_for_status()
            
            data = response.json()
            shodan_results = data.get("matches", [])
            current_shodan_result_index = 0
            
            # Update UI in main thread
            root.after(0, lambda: display_shodan_results())
            
        except Exception as e:
            root.after(0, lambda: messagebox.showerror("Error", f"Shodan search failed: {str(e)}"))
    
    # Disable next result button while searching
    next_result_button.config(state=tk.DISABLED)
    threading.Thread(target=search_thread, daemon=True).start()

def update_feed():
    if is_fetching:
        messagebox.showwarning("INFO:", "operation in progress.")
        return
        
    def update_thread():
        try:
            cves = fetch_cves()
            # Update GUI in the main thread
            root.after(0, lambda: update_feed_display(cves))
        except Exception as e:
            root.after(0, lambda: status_label.config(text=f"Error: {e}", fg="red"))
    status_label.config(text="Fetching CVEs...", fg="yellow")
    threading.Thread(target=update_thread, daemon=True).start()

def fetch_cves():
    global is_fetching, last_update_time
    try:
        is_fetching = True
        status_label.config(text="Fetching CVEs...", fg="yellow")
        root.update_idletasks()

        if not nist_api_key:
            messagebox.showwarning("Warning", "Please set your NIST API key first")
            return []
        cached_cves = load_cache()
        if cached_cves:
            last_update_time = datetime.now()
            status_label.config(text="Loaded from cache", fg="green")
            return cached_cves

        # If no cache or expired, fetch from API
        status_label.config(text="Fetching new CVEs...", fg="yellow")
        headers = {
            'apiKey': nist_api_key
        }
        
        # Calculate date range (previous day to current day)
        end_date = datetime.now()
        start_date = end_date - timedelta(days=1)
        
        start_date_str = start_date.strftime("%Y-%m-%dT%H:%M:%S.000+01:00")
        end_date_str = end_date.strftime("%Y-%m-%dT%H:%M:%S.000+01:00")
        
        results_per_page = 20
        start_index = 0
        all_cves = []
        
        while True:
            url = "https://services.nvd.nist.gov/rest/json/cves/2.0/"
            params = {
                'lastModStartDate': start_date_str,
                'lastModEndDate': end_date_str,
                'resultsPerPage': results_per_page,
                'startIndex': start_index
            }
            
            try:
                response = requests.get(url, headers=headers, params=params, timeout=30)
                print(f"Requesting URL: {response.url}")
                
                response.raise_for_status()
                data = response.json()
                vulnerabilities = data.get("vulnerabilities", [])
                print(f"found {len(vulnerabilities)} vulns here")
                if not vulnerabilities:
                    print("nothing")
                    break
                    
                all_cves.extend(vulnerabilities)
                
                # Update status with progress
                status_label.config(text=f"Fetching CVEs... ({len(all_cves)} found so far)", fg="yellow")
                root.update_idletasks()
                
                total_results = data.get("totalResults", 0)
                if start_index + results_per_page >= total_results:
                    break
                    
                start_index += results_per_page
                time.sleep(6)  # Rate limiting
                
            except requests.exceptions.RequestException as e:
                print(f"Request failed: {e}")
                if hasattr(e, 'response') and e.response is not None:
                    print(f"Response status code: {e.response.status_code}")
                    print(f"Response text: {e.response.text}")
                break
        if all_cves:
            save_cache(all_cves)
                
        last_update_time = datetime.now()
        return all_cves
        
    except Exception as e:
        status_label.config(text=f"An error occurred: {e}", fg="red")
        print(f"An error occurred: {e}")
        return []
    finally:
        is_fetching = False

def update_feed_display(cves):
    try:
        print(f"Updating feed with {len(cves)} CVEs")
        feed_text.config(state=tk.NORMAL)
        feed_text.delete(1.0, tk.END)
        
        if not cves:
            feed_text.insert(tk.END, "No CVEs found for the specified date range.\n")
        else:
            for cve in cves:
                cve_data = cve.get("cve", {})
                cve_id = cve_data.get("id", "Unknown")
                published = cve_data.get("published", "Unknown")
                description = cve_data.get("descriptions", [{}])[0].get("value", "No description available.")
                
                # Extract severity from description
                severity = extract_severity(description)

                # Insert CVE information
                feed_text.insert(tk.END, "\nCVE ID: ", 'yellow')
                feed_text.insert(tk.END, f"{cve_id}\n")
                feed_text.insert(tk.END, "Published: ", 'yellow')
                feed_text.insert(tk.END, f"{published}\n")

                
                severity_tag = f"severity_{severity.lower()}" if severity.lower() in ['high', 'medium', 'low', 'critical'] else None
                feed_text.insert(tk.END, "Severity: ", 'yellow')
                feed_text.insert(tk.END, f"{severity}\n", severity_tag)
                feed_text.insert(tk.END, "Description: ", 'yellow')
                feed_text.insert(tk.END, f"{description}\n")
                
                # Extract and display affected systems
                configurations = cve.get("configurations", [])
                affected_systems = []
                
                # Collect all affected systems first
                for config in configurations:
                    nodes = config.get("nodes", [])
                    for node in nodes:
                        cpe_match = node.get("cpeMatch", [])
                        for match in cpe_match:
                            criteria = match.get("criteria", "")
                            if criteria:
                                # Clean up the CPE criteria for better readability
                                criteria = criteria.replace("cpe:2.3:", "")
                                parts = criteria.split(":")
                                if len(parts) >= 3:
                                    vendor = parts[0]
                                    product = parts[1]
                                    version = parts[2]
                                    affected_systems.append(f"- {vendor}:{product}:{version}")
                
                # Only display the Affected Systems section if there are systems to show
                if affected_systems:
                    feed_text.insert(tk.END, "Affected Systems:\n", 'yellow')
                    for system in affected_systems:
                        feed_text.insert(tk.END, f"{system}\n")
                
                feed_text.insert(tk.END, "-"*80 + "\n")
                feed_text.see(tk.END)
        
        feed_text.config(state=tk.DISABLED)
        if last_update_time:
            status_label.config(text=f"Found {len(cves)} CVEs. Last updated: {last_update_time.strftime('%Y-%m-%d %H:%M:%S')}", fg="green")
        else:
            status_label.config(text=f"Found {len(cves)} CVEs.", fg="green")
        
    except Exception as e:
        status_label.config(text=f"Error updating display: {e}", fg="red")
        print(f"Error updating display: {e}")

def load_cache():
    """Load cached CVE data if it exists and is not expired"""
    try:
        if os.path.exists(CACHE_FILE):
            with open(CACHE_FILE, 'r') as f:
                cache_data = json.load(f)
                cache_time = datetime.fromisoformat(cache_data['timestamp'])
                
                # Check if cache is expired
                if datetime.now() - cache_time < timedelta(hours=CACHE_EXPIRY_HOURS):
                    print(f"Loading {len(cache_data['cves'])} CVEs from cache")
                    return cache_data['cves']
                else:
                    print("Cache expired, fetching fresh data")
    except Exception as e:
        print(f"Cache read error: {e}")
    return None

def save_cache(cves):
    """Save CVE data to cache file"""
    try:
        cache_data = {
            'timestamp': datetime.now().isoformat(),
            'cves': cves
        }
        with open(CACHE_FILE, 'w') as f:
            json.dump(cache_data, f)
        print(f"Cached {len(cves)} CVEs")
    except Exception as e:
        print(f"Cache write error: {e}")
        
def export_to_json():
    if is_fetching:
        messagebox.showwarning("Warning", "A fetch operation is already in progress. Please wait.")
        return
        
    def export_thread():
        cves = fetch_cves()
        root.after(0, lambda: save_json(cves))
    
    threading.Thread(target=export_thread, daemon=True).start()

def save_json(cves):
    file_path = filedialog.asksaveasfilename(
        defaultextension=".json",
        filetypes=[("JSON files", "*.json"), ("All files", "*.*")]
    )
    if file_path:
        with open(file_path, 'w') as f:
            json.dump(cves, f, indent=4)
        messagebox.showinfo("Export Successful", "Data exported to JSON successfully!")

def refresh_feed_daily():
    if is_started:
        update_feed()
        # Schedule next update in 24 hours
        root.after(86400000, refresh_feed_daily)  # 24 hours in milliseconds

def update_status_label():
    if not nist_api_key:
        status_label.config(text="Ready - Enter NIST API key to start", fg="yellow")
    elif not shodan_api_key:
        status_label.config(text="Ready - NIST API key set. Shodan searches disabled.", fg="orange")
    else:
        status_label.config(text="Ready - Both API keys configured", fg="green")

def create_gui():
    global root, status_label, feed_text, feed_frame, shodan_results_text, next_result_button, start_button, manual_search_entry, manual_search_button, shodan_frame
    
    # GUI Setup with Dark Mode
    root = tk.Tk()
    root.title("CVE Threat Feed - LTH Cybersecurity")
    root.geometry("1200x800")
    root.configure(bg="#1e1e1e")
    try:
        icon_path = get_resource_path('lth.png')
        icon = tk.PhotoImage(file=icon_path)
        root.iconphoto(True, icon)
    except Exception as e:
        print(f"Could not load application icon: {e}")
    # Taskbar with Buttons
    taskbar = tk.Frame(root, bg="#333333")
    taskbar.pack(side=tk.TOP, fill=tk.X)

    start_button = tk.Button(taskbar, text="Start Feed", command=start_feed, bg="#555555", fg="white", state=tk.DISABLED)
    start_button.pack(side=tk.LEFT, padx=10, pady=10)

    refresh_button = tk.Button(taskbar, text="Refresh Feed", command=update_feed, bg="#555555", fg="white")
    refresh_button.pack(side=tk.LEFT, padx=10)

    api_keys_button = tk.Button(taskbar, text="API Keys", command=show_api_keys_window, bg="#555555", fg="white")
    api_keys_button.pack(side=tk.LEFT, padx=10)

    export_button = tk.Button(taskbar, text="Export to JSON", command=export_to_json, bg="#555555", fg="white")
    export_button.pack(side=tk.LEFT, padx=10)
    
    # Add toggle button for Shodan panel
    toggle_shodan_button = tk.Button(taskbar, text="Toggle Shodan Panel", 
                                   command=toggle_shodan_panel, 
                                   bg="#555555", fg="white")
    toggle_shodan_button.pack(side=tk.LEFT, padx=10)
    
    exit_button = tk.Button(taskbar, text="Exit", command=root.quit, bg="#555555", fg="white")
    exit_button.pack(side=tk.RIGHT, padx=10)

    # Main content area
    content_frame = tk.Frame(root, bg="#1e1e1e")
    content_frame.pack(fill=tk.BOTH, expand=True)

    # Feed Display
    feed_frame = tk.Frame(content_frame, bg="#1e1e1e")
    feed_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

    feed_text = tk.Text(feed_frame, wrap=tk.WORD, state=tk.DISABLED, bg="#1e1e1e", fg="white", font=("Consolas", 10))
    feed_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

    scrollbar = ttk.Scrollbar(feed_frame, orient="vertical", command=feed_text.yview)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
    feed_text.config(yscrollcommand=scrollbar.set)

    # Shodan Results Panel
    shodan_frame = tk.Frame(content_frame, bg="#1e1e1e", width=400)  # Set fixed width
    shodan_frame.pack(side=tk.RIGHT, fill=tk.Y, expand=False)
    shodan_frame.pack_propagate(False)  # Prevent frame from shrinking

    shodan_label = tk.Label(shodan_frame, text="Shodan Results", bg="#1e1e1e", fg="white", font=("Arial", 12))
    shodan_label.pack(pady=5)

    # Manual CVE Search
    manual_search_frame = tk.Frame(shodan_frame, bg="#1e1e1e")
    manual_search_frame.pack(fill=tk.X, padx=5, pady=5)

    manual_search_label = tk.Label(manual_search_frame, text="Search CVE:", bg="#1e1e1e", fg="white")
    manual_search_label.pack(side=tk.LEFT)

    manual_search_entry = tk.Entry(manual_search_frame, bg="#333333", fg="white", width=30)
    manual_search_entry.pack(side=tk.LEFT, padx=5)

    manual_search_button = tk.Button(manual_search_frame, text="Search", 
                                   command=lambda: search_shodan(None), bg="#555555", fg="white")
    manual_search_button.pack(side=tk.LEFT)

    shodan_results_text = tk.Text(shodan_frame, wrap=tk.WORD, state=tk.DISABLED, 
                                 bg="#1e1e1e", fg="white", font=("Consolas", 10), height=20)
    shodan_results_text.pack(fill=tk.BOTH, expand=True)

    next_result_button = tk.Button(shodan_frame, text="Next Result", 
                                  command=display_shodan_results, bg="#555555", fg="white",
                                  state=tk.DISABLED)
    next_result_button.pack(pady=5)

    # Status Label
    status_label = tk.Label(root, text="Ready - Enter NIST API Key To Start", bg="#1e1e1e", fg="white", font=("Arial", 12))
    status_label.pack(side=tk.BOTTOM, fill=tk.X)
   
    # Configure text tags
    feed_text.tag_configure('yellow', foreground='yellow')
    feed_text.tag_configure('blue', foreground='#00ffff')
    feed_text.tag_configure('severity_high', foreground='red')
    feed_text.tag_configure('severity_medium', foreground='orange')
    feed_text.tag_configure('severity_low', foreground='green')
    feed_text.tag_configure('severity_critical', foreground='red')

    return root

def toggle_shodan_panel():
    if shodan_frame.winfo_ismapped():
        shodan_frame.pack_forget()
        feed_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    else:
        feed_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        shodan_frame.pack(side=tk.RIGHT, fill=tk.Y, expand=False)

if __name__ == "__main__":
    root = create_gui()
    root.mainloop()
